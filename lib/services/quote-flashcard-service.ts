import { createClient } from '@/lib/supabase/client'
import { 
  Quote, 
  Theme, 
  QuoteTheme, 
  FlashcardCard, 
  StudentCardSet, 
  StudentCardSetItem, 
  CardProgress,
  Book 
} from '@/lib/types/database'

// Extended types with relationships
export interface QuoteWithDetails extends Quote {
  book?: Book
  themes?: Theme[]
  cards?: FlashcardCard[]
  card_count?: number
}

export interface FlashcardCardWithDetails extends FlashcardCard {
  quote?: Quote
  book?: Book
  themes?: Theme[]
  progress?: CardProgress
}

export interface StudentCardSetWithDetails extends StudentCardSet {
  cards?: FlashcardCardWithDetails[]
  card_count?: number
}

export interface NewQuote {
  title: string
  text: string
  book_id: string
  source?: string
  theme_ids?: string[]
}

export interface NewStudentCardSet {
  name: string
  description?: string
}

export interface CardFilters {
  book_id?: string
  theme_ids?: string[]
  search?: string
  difficulty_level?: number
  only_active?: boolean
}

export class QuoteFlashcardService {
  private supabase = createClient()

  // ============================================================================
  // QUOTE MANAGEMENT
  // ============================================================================

  async createQuote(userId: string, newQuote: NewQuote): Promise<QuoteWithDetails | null> {
    try {
      // Create the quote
      const { data: quote, error: quoteError } = await this.supabase
        .from('quotes')
        .insert({
          title: newQuote.title,
          text: newQuote.text,
          book_id: newQuote.book_id,
          source: newQuote.source,
          created_by: userId,
          is_active: true
        })
        .select('*')
        .single()

      if (quoteError) {
        console.error('Error creating quote:', quoteError)
        return null
      }

      // Add theme relationships if provided
      if (newQuote.theme_ids && newQuote.theme_ids.length > 0) {
        const themeRelations = newQuote.theme_ids.map(theme_id => ({
          quote_id: quote.id,
          theme_id
        }))

        await this.supabase
          .from('quote_themes')
          .insert(themeRelations)
      }

      // Note: Flashcard cards are auto-generated by the database trigger

      return this.getQuoteWithDetails(quote.id)
    } catch (error) {
      console.error('Error in createQuote:', error)
      return null
    }
  }

  async getQuoteWithDetails(quoteId: string): Promise<QuoteWithDetails | null> {
    try {
      const { data: quote, error: quoteError } = await this.supabase
        .from('quotes')
        .select(`
          *,
          books (
            id, title, author, category
          )
        `)
        .eq('id', quoteId)
        .single()

      if (quoteError || !quote) {
        return null
      }

      // Get themes
      const { data: themeData } = await this.supabase
        .from('quote_themes')
        .select(`
          themes (
            id, name, description, color
          )
        `)
        .eq('quote_id', quoteId)

      const themes = themeData?.map(t => t.themes).filter(Boolean) || []

      // Get cards count
      const { count: cardCount } = await this.supabase
        .from('flashcard_cards')
        .select('*', { count: 'exact', head: true })
        .eq('quote_id', quoteId)
        .eq('is_active', true)

      return {
        ...quote,
        book: quote.books,
        themes,
        card_count: cardCount || 0
      }
    } catch (error) {
      console.error('Error in getQuoteWithDetails:', error)
      return null
    }
  }

  async getAllQuotes(filters: CardFilters = {}): Promise<QuoteWithDetails[]> {
    try {
      let query = this.supabase
        .from('quotes')
        .select(`
          *,
          books (
            id, title, author, category
          )
        `)

      if (filters.only_active !== false) {
        query = query.eq('is_active', true)
      }

      if (filters.book_id) {
        query = query.eq('book_id', filters.book_id)
      }

      if (filters.search) {
        query = query.or(`title.ilike.%${filters.search}%,text.ilike.%${filters.search}%`)
      }

      const { data: quotes, error } = await query.order('created_at', { ascending: false })

      if (error || !quotes) {
        return []
      }

      // Get themes for each quote if theme filter is applied
      const quotesWithDetails = await Promise.all(
        quotes.map(async (quote) => {
          const { data: themeData } = await this.supabase
            .from('quote_themes')
            .select(`
              themes (
                id, name, description, color
              )
            `)
            .eq('quote_id', quote.id)

          const themes = themeData?.map(t => t.themes).filter(Boolean) || []

          // If theme filter is applied, check if quote matches
          if (filters.theme_ids && filters.theme_ids.length > 0) {
            const quoteThemeIds = themes.map(t => t.id)
            const hasMatchingTheme = filters.theme_ids.some(id => quoteThemeIds.includes(id))
            if (!hasMatchingTheme) {
              return null
            }
          }

          // Get card count
          const { count: cardCount } = await this.supabase
            .from('flashcard_cards')
            .select('*', { count: 'exact', head: true })
            .eq('quote_id', quote.id)
            .eq('is_active', true)

          return {
            ...quote,
            book: quote.books,
            themes,
            card_count: cardCount || 0
          }
        })
      )

      return quotesWithDetails.filter(Boolean) as QuoteWithDetails[]
    } catch (error) {
      console.error('Error in getAllQuotes:', error)
      return []
    }
  }

  async updateQuote(quoteId: string, updates: Partial<NewQuote>): Promise<boolean> {
    try {
      // Update quote
      const { error: quoteError } = await this.supabase
        .from('quotes')
        .update({
          title: updates.title,
          text: updates.text,
          book_id: updates.book_id,
          source: updates.source
        })
        .eq('id', quoteId)

      if (quoteError) {
        console.error('Error updating quote:', quoteError)
        return false
      }

      // Update themes if provided
      if (updates.theme_ids !== undefined) {
        // Remove existing theme relationships
        await this.supabase
          .from('quote_themes')
          .delete()
          .eq('quote_id', quoteId)

        // Add new theme relationships
        if (updates.theme_ids.length > 0) {
          const themeRelations = updates.theme_ids.map(theme_id => ({
            quote_id: quoteId,
            theme_id
          }))

          await this.supabase
            .from('quote_themes')
            .insert(themeRelations)
        }
      }

      return true
    } catch (error) {
      console.error('Error in updateQuote:', error)
      return false
    }
  }

  async deleteQuote(quoteId: string): Promise<boolean> {
    try {
      const { error } = await this.supabase
        .from('quotes')
        .delete()
        .eq('id', quoteId)

      return !error
    } catch (error) {
      console.error('Error in deleteQuote:', error)
      return false
    }
  }

  async toggleQuoteActive(quoteId: string, isActive: boolean): Promise<boolean> {
    try {
      const { error } = await this.supabase
        .from('quotes')
        .update({ is_active: isActive })
        .eq('id', quoteId)

      return !error
    } catch (error) {
      console.error('Error in toggleQuoteActive:', error)
      return false
    }
  }

  // ============================================================================
  // THEME MANAGEMENT
  // ============================================================================

  async getAllThemes(): Promise<Theme[]> {
    try {
      const { data, error } = await this.supabase
        .from('themes')
        .select('*')
        .order('name')

      return data || []
    } catch (error) {
      console.error('Error in getAllThemes:', error)
      return []
    }
  }

  async createTheme(theme: { name: string; description?: string; color?: string }): Promise<Theme | null> {
    try {
      const { data, error } = await this.supabase
        .from('themes')
        .insert(theme)
        .select('*')
        .single()

      return error ? null : data
    } catch (error) {
      console.error('Error in createTheme:', error)
      return null
    }
  }

  async updateTheme(themeId: string, updates: Partial<Theme>): Promise<boolean> {
    try {
      const { error } = await this.supabase
        .from('themes')
        .update(updates)
        .eq('id', themeId)

      return !error
    } catch (error) {
      console.error('Error in updateTheme:', error)
      return false
    }
  }

  async deleteTheme(themeId: string): Promise<boolean> {
    try {
      const { error } = await this.supabase
        .from('themes')
        .delete()
        .eq('id', themeId)

      return !error
    } catch (error) {
      console.error('Error in deleteTheme:', error)
      return false
    }
  }

  // ============================================================================
  // FLASHCARD CARD MANAGEMENT
  // ============================================================================

  async getCardsForStudy(filters: CardFilters = {}): Promise<FlashcardCardWithDetails[]> {
    try {
      let query = this.supabase
        .from('flashcard_cards')
        .select(`
          *,
          quotes (
            id, title, text, book_id, source,
            books (
              id, title, author, category
            )
          )
        `)

      if (filters.only_active !== false) {
        query = query.eq('is_active', true)
      }

      if (filters.difficulty_level) {
        query = query.eq('difficulty_level', filters.difficulty_level)
      }

      const { data: cards, error } = await query.order('created_at', { ascending: false })

      if (error || !cards) {
        return []
      }

      // Apply additional filters and get themes
      const cardsWithDetails = await Promise.all(
        cards.map(async (card) => {
          const quote = card.quotes
          
          if (!quote) return null

          // Book filter
          if (filters.book_id && quote.book_id !== filters.book_id) {
            return null
          }

          // Search filter
          if (filters.search) {
            const searchTerm = filters.search.toLowerCase()
            const matchesTitle = quote.title.toLowerCase().includes(searchTerm)
            const matchesText = quote.text.toLowerCase().includes(searchTerm)
            const matchesSource = quote.source?.toLowerCase().includes(searchTerm)
            if (!matchesTitle && !matchesText && !matchesSource) {
              return null
            }
          }

          // Get themes
          const { data: themeData } = await this.supabase
            .from('quote_themes')
            .select(`
              themes (
                id, name, description, color
              )
            `)
            .eq('quote_id', quote.id)

          const themes = themeData?.map(t => t.themes).filter(Boolean) || []

          // Theme filter
          if (filters.theme_ids && filters.theme_ids.length > 0) {
            const quoteThemeIds = themes.map(t => t.id)
            const hasMatchingTheme = filters.theme_ids.some(id => quoteThemeIds.includes(id))
            if (!hasMatchingTheme) {
              return null
            }
          }

          return {
            ...card,
            quote: {
              ...quote,
              book: quote.books
            },
            book: quote.books,
            themes
          }
        })
      )

      return cardsWithDetails.filter(Boolean) as FlashcardCardWithDetails[]
    } catch (error) {
      console.error('Error in getCardsForStudy:', error)
      return []
    }
  }

  async getCardById(cardId: string): Promise<FlashcardCardWithDetails | null> {
    try {
      const { data: card, error } = await this.supabase
        .from('flashcard_cards')
        .select(`
          *,
          quotes (
            id, title, text, book_id, source,
            books (
              id, title, author, category
            )
          )
        `)
        .eq('id', cardId)
        .single()

      if (error || !card || !card.quotes) {
        return null
      }

      // Get themes
      const { data: themeData } = await this.supabase
        .from('quote_themes')
        .select(`
          themes (
            id, name, description, color
          )
        `)
        .eq('quote_id', card.quotes.id)

      const themes = themeData?.map(t => t.themes).filter(Boolean) || []

      return {
        ...card,
        quote: {
          ...card.quotes,
          book: card.quotes.books
        },
        book: card.quotes.books,
        themes
      }
    } catch (error) {
      console.error('Error in getCardById:', error)
      return null
    }
  }

  async updateCard(cardId: string, updates: Partial<FlashcardCard>): Promise<boolean> {
    try {
      const { error } = await this.supabase
        .from('flashcard_cards')
        .update(updates)
        .eq('id', cardId)

      return !error
    } catch (error) {
      console.error('Error in updateCard:', error)
      return false
    }
  }

  async toggleCardActive(cardId: string, isActive: boolean): Promise<boolean> {
    try {
      const { error } = await this.supabase
        .from('flashcard_cards')
        .update({ is_active: isActive })
        .eq('id', cardId)

      return !error
    } catch (error) {
      console.error('Error in toggleCardActive:', error)
      return false
    }
  }

  // ============================================================================
  // STUDENT WORKSPACE
  // ============================================================================

  async getStudentCardSets(userId: string): Promise<StudentCardSetWithDetails[]> {
    try {
      const { data: sets, error } = await this.supabase
        .from('student_card_sets')
        .select(`
          *,
          student_card_set_items (
            card_id
          )
        `)
        .eq('user_id', userId)
        .order('created_at', { ascending: false })

      if (error || !sets) {
        return []
      }

      return sets.map(set => ({
        ...set,
        card_count: set.student_card_set_items?.length || 0
      }))
    } catch (error) {
      console.error('Error in getStudentCardSets:', error)
      return []
    }
  }

  async createStudentCardSet(userId: string, newSet: NewStudentCardSet): Promise<StudentCardSet | null> {
    try {
      const { data, error } = await this.supabase
        .from('student_card_sets')
        .insert({
          user_id: userId,
          name: newSet.name,
          description: newSet.description
        })
        .select('*')
        .single()

      return error ? null : data
    } catch (error) {
      console.error('Error in createStudentCardSet:', error)
      return null
    }
  }

  async addCardToSet(setId: string, cardId: string): Promise<boolean> {
    try {
      const { error } = await this.supabase
        .from('student_card_set_items')
        .insert({
          set_id: setId,
          card_id: cardId
        })

      return !error
    } catch (error) {
      console.error('Error in addCardToSet:', error)
      return false
    }
  }

  async removeCardFromSet(setId: string, cardId: string): Promise<boolean> {
    try {
      const { error } = await this.supabase
        .from('student_card_set_items')
        .delete()
        .eq('set_id', setId)
        .eq('card_id', cardId)

      return !error
    } catch (error) {
      console.error('Error in removeCardFromSet:', error)
      return false
    }
  }

  async deleteStudentCardSet(setId: string): Promise<boolean> {
    try {
      // First delete all items in the set
      const { error: itemsError } = await this.supabase
        .from('student_card_set_items')
        .delete()
        .eq('set_id', setId)

      if (itemsError) {
        console.error('Error deleting set items:', itemsError)
        return false
      }

      // Then delete the set itself
      const { error: setError } = await this.supabase
        .from('student_card_sets')
        .delete()
        .eq('id', setId)

      return !setError
    } catch (error) {
      console.error('Error in deleteStudentCardSet:', error)
      return false
    }
  }

  async updateStudentCardSet(setId: string, updates: Partial<NewStudentCardSet>): Promise<boolean> {
    try {
      const { error } = await this.supabase
        .from('student_card_sets')
        .update(updates)
        .eq('id', setId)

      return !error
    } catch (error) {
      console.error('Error in updateStudentCardSet:', error)
      return false
    }
  }

  async getCardsInSet(setId: string): Promise<FlashcardCardWithDetails[]> {
    try {
      const { data: items, error } = await this.supabase
        .from('student_card_set_items')
        .select(`
          card_id,
          flashcard_cards (
            *,
            quotes (
              id, title, text, book_id, source,
              books (
                id, title, author, category
              )
            )
          )
        `)
        .eq('set_id', setId)

      if (error || !items) {
        return []
      }

      const cardsWithDetails = await Promise.all(
        items.map(async (item) => {
          const card = item.flashcard_cards
          if (!card || !card.quotes) return null

          // Get themes
          const { data: themeData } = await this.supabase
            .from('quote_themes')
            .select(`
              themes (
                id, name, description, color
              )
            `)
            .eq('quote_id', card.quotes.id)

          const themes = themeData?.map(t => t.themes).filter(Boolean) || []

          return {
            ...card,
            quote: {
              ...card.quotes,
              book: card.quotes.books
            },
            book: card.quotes.books,
            themes
          }
        })
      )

      return cardsWithDetails.filter(Boolean) as FlashcardCardWithDetails[]
    } catch (error) {
      console.error('Error in getCardsInSet:', error)
      return []
    }
  }

  // ============================================================================
  // PROGRESS TRACKING
  // ============================================================================

  async updateCardProgress(
    userId: string, 
    cardId: string, 
    isCorrect: boolean,
    timeSpent?: number
  ): Promise<boolean> {
    try {
      // Get current progress
      const { data: currentProgress } = await this.supabase
        .from('card_progress')
        .select('*')
        .eq('user_id', userId)
        .eq('card_id', cardId)
        .maybeSingle()

      const now = new Date().toISOString()
      
      if (currentProgress) {
        // Update existing progress
        const newAttempts = currentProgress.attempts + 1
        const newCorrectAttempts = currentProgress.correct_attempts + (isCorrect ? 1 : 0)
        
        // Simple spaced repetition calculation
        let newEaseFactor = currentProgress.ease_factor
        let newIntervalDays = currentProgress.interval_days

        if (isCorrect) {
          newEaseFactor = Math.min(3.0, newEaseFactor + 0.1)
          newIntervalDays = Math.ceil(newIntervalDays * newEaseFactor)
        } else {
          newEaseFactor = Math.max(1.3, newEaseFactor - 0.2)
          newIntervalDays = 1
        }

        const nextReviewDate = new Date()
        nextReviewDate.setDate(nextReviewDate.getDate() + newIntervalDays)

        const { error } = await this.supabase
          .from('card_progress')
          .update({
            attempts: newAttempts,
            correct_attempts: newCorrectAttempts,
            last_attempt_at: now,
            next_review_at: nextReviewDate.toISOString(),
            ease_factor: newEaseFactor,
            interval_days: newIntervalDays
          })
          .eq('id', currentProgress.id)

        return !error
      } else {
        // Create new progress record
        const nextReviewDate = new Date()
        nextReviewDate.setDate(nextReviewDate.getDate() + (isCorrect ? 2 : 1))

        const { error } = await this.supabase
          .from('card_progress')
          .insert({
            user_id: userId,
            card_id: cardId,
            attempts: 1,
            correct_attempts: isCorrect ? 1 : 0,
            last_attempt_at: now,
            next_review_at: nextReviewDate.toISOString(),
            ease_factor: isCorrect ? 2.6 : 2.3,
            interval_days: isCorrect ? 2 : 1
          })

        return !error
      }
    } catch (error) {
      console.error('Error in updateCardProgress:', error)
      return false
    }
  }

  async getCardProgress(userId: string, cardId: string): Promise<CardProgress | null> {
    try {
      const { data, error } = await this.supabase
        .from('card_progress')
        .select('*')
        .eq('user_id', userId)
        .eq('card_id', cardId)
        .maybeSingle()

      return error ? null : data
    } catch (error) {
      console.error('Error in getCardProgress:', error)
      return null
    }
  }

  async getCardsForReview(userId: string, limit: number = 20): Promise<FlashcardCardWithDetails[]> {
    try {
      const now = new Date().toISOString()
      
      const { data: progressData, error } = await this.supabase
        .from('card_progress')
        .select(`
          card_id,
          flashcard_cards (
            *,
            quotes (
              id, title, text, book_id, source,
              books (
                id, title, author, category
              )
            )
          )
        `)
        .eq('user_id', userId)
        .lte('next_review_at', now)
        .limit(limit)

      if (error || !progressData) {
        return []
      }

      const cardsWithDetails = await Promise.all(
        progressData.map(async (item) => {
          const card = item.flashcard_cards
          if (!card || !card.quotes) return null

          // Get themes
          const { data: themeData } = await this.supabase
            .from('quote_themes')
            .select(`
              themes (
                id, name, description, color
              )
            `)
            .eq('quote_id', card.quotes.id)

          const themes = themeData?.map(t => t.themes).filter(Boolean) || []

          return {
            ...card,
            quote: {
              ...card.quotes,
              book: card.quotes.books
            },
            book: card.quotes.books,
            themes
          }
        })
      )

      return cardsWithDetails.filter(Boolean) as FlashcardCardWithDetails[]
    } catch (error) {
      console.error('Error in getCardsForReview:', error)
      return []
    }
  }

  // ============================================================================
  // BULK OPERATIONS
  // ============================================================================

  async bulkDeleteCards(cardIds: string[]): Promise<boolean> {
    try {
      // First delete any related card progress records
      const { error: progressError } = await this.supabase
        .from('card_progress')
        .delete()
        .in('card_id', cardIds)

      if (progressError) {
        console.error('Error deleting card progress:', progressError)
        return false
      }

      // Delete from student card sets
      const { error: setItemsError } = await this.supabase
        .from('student_card_set_items')
        .delete()
        .in('card_id', cardIds)

      if (setItemsError) {
        console.error('Error deleting from student sets:', setItemsError)
        return false
      }

      // Finally delete the cards themselves
      const { error: cardsError } = await this.supabase
        .from('flashcard_cards')
        .delete()
        .in('id', cardIds)

      return !cardsError
    } catch (error) {
      console.error('Error in bulkDeleteCards:', error)
      return false
    }
  }

  async bulkArchiveCards(cardIds: string[], archived: boolean = true): Promise<boolean> {
    try {
      // Use is_active column for archive functionality (archived = !active)
      const { error } = await this.supabase
        .from('flashcard_cards')
        .update({ is_active: !archived })
        .in('id', cardIds)

      return !error
    } catch (error) {
      console.error('Error in bulkArchiveCards:', error)
      return false
    }
  }

  async bulkUpdateCardThemes(cardIds: string[], themeIds: string[]): Promise<boolean> {
    try {
      // Get the quote IDs for these cards
      const { data: cards, error: cardsError } = await this.supabase
        .from('flashcard_cards')
        .select('quote_id')
        .in('id', cardIds)

      if (cardsError || !cards) {
        console.error('Error getting card quote IDs:', cardsError)
        return false
      }

      const quoteIds = cards.map(card => card.quote_id)

      // Remove existing theme relationships for these quotes
      const { error: deleteError } = await this.supabase
        .from('quote_themes')
        .delete()
        .in('quote_id', quoteIds)

      if (deleteError) {
        console.error('Error removing existing themes:', deleteError)
        return false
      }

      // Add new theme relationships
      if (themeIds.length > 0) {
        const themeRelations = []
        for (const quoteId of quoteIds) {
          for (const themeId of themeIds) {
            themeRelations.push({
              quote_id: quoteId,
              theme_id: themeId
            })
          }
        }

        const { error: insertError } = await this.supabase
          .from('quote_themes')
          .insert(themeRelations)

        if (insertError) {
          console.error('Error adding new themes:', insertError)
          return false
        }
      }

      return true
    } catch (error) {
      console.error('Error in bulkUpdateCardThemes:', error)
      return false
    }
  }

  async bulkRegenerateCards(cardIds: string[]): Promise<boolean> {
    try {
      // Get the cards and their quotes
      const { data: cards, error: cardsError } = await this.supabase
        .from('flashcard_cards')
        .select(`
          id,
          quote_id,
          quotes (
            id, text
          )
        `)
        .in('id', cardIds)

      if (cardsError || !cards) {
        console.error('Error getting cards for regeneration:', cardsError)
        return false
      }

      // Delete existing cards
      const deleteSuccess = await this.bulkDeleteCards(cardIds)
      if (!deleteSuccess) {
        return false
      }

      // Regenerate cards by calling the database function for each quote
      for (const card of cards) {
        if (card.quotes) {
          await this.supabase.rpc('generate_flashcard_cards_for_quote', {
            quote_id: card.quotes.id
          })
        }
      }

      return true
    } catch (error) {
      console.error('Error in bulkRegenerateCards:', error)
      return false
    }
  }

  async bulkToggleActive(cardIds: string[], isActive: boolean): Promise<boolean> {
    try {
      const { error } = await this.supabase
        .from('flashcard_cards')
        .update({ is_active: isActive })
        .in('id', cardIds)

      return !error
    } catch (error) {
      console.error('Error in bulkToggleActive:', error)
      return false
    }
  }
}

export const quoteFlashcardService = new QuoteFlashcardService() 